# 数独求解器实现详解

## 概述

本项目的数独求解器基于 jczsolve 算法，是目前已知最快的数独求解算法之一。它结合了高效的逻辑推理和智能搜索策略，能够快速解决任何有效的数独谜题。

## 核心策略

求解器主要使用三种策略的组合：

1. **Naked Singles（裸单元格）**
   - 寻找只能填入一个数字的单元格
   - 通过位掩码快速计算每个单元格的可能数字
   - 当发现裸单元格时立即填入数字

2. **Locked Candidates（锁定候选数）**
   - 在行、列或宫中寻找数字的唯一可能位置
   - 使用带状数据结构高效处理这些约束
   - 通过位运算快速更新可能数字

3. **Backtracking（回溯）**
   - 当逻辑推理无法继续时使用
   - 智能选择猜测点，优先选择只有两个可能值的单元格
   - 保存状态以便回退

## 数据结构

### 带状数据结构

求解器使用带状数据结构来表示数独：

```
Bands  Rows                   Columns
               0    1    2    3    4    5    6    7    8
            ┏━━━━┯━━━━┯━━━━┳━━━━┯━━━━┯━━━━┳━━━━┯━━━━┯━━━━┓
     ┏   0  ┃ 00 │ 01 │ 02 ┃ 03 │ 04 │ 05 ┃ 06 │ 07 │ 08 ┃
     ┃      ┠────┼────┼────╂────┼────┼────╂────┼────┼────┨
   0 ┫   1  ┃ 09 │ 10 │ 11 ┃ 12 │ 13 │ 14 ┃ 15 │ 16 │ 17 ┃
     ┃      ┠────┼────┼────╂────┼────┼────╂────┼────┼────┨
     ┗   2  ┃ 18 │ 19 │ 20 ┃ 21 │ 22 │ 23 ┃ 24 │ 25 │ 26 ┃
            ┣━━━━┿━━━━┿━━━━╋━━━━┿━━━━┿━━━━╋━━━━┿━━━━┿━━━━┫
     ┏   3  ┃ 27 │ 28 │ 29 ┃ 30 │ 31 │ 32 ┃ 33 │ 34 │ 35 ┃
     ┃      ┠────┼────┼────╂────┼────┼────╂────┼────┼────┨
   1 ┫   4  ┃ 36 │ 37 │ 38 ┃ 39 │ 40 │ 41 ┃ 42 │ 43 │ 44 ┃
     ┃      ┠────┼────┼────╂────┼────┼────╂────┼────┼────┨
     ┗   5  ┃ 45 │ 46 │ 47 ┃ 48 │ 49 │ 50 ┃ 51 │ 52 │ 53 ┃
            ┣━━━━┿━━━━┿━━━━╋━━━━┿━━━━┿━━━━╋━━━━┿━━━━┿━━━━┫
     ┏   6  ┃ 54 │ 55 │ 56 ┃ 57 │ 58 │ 59 ┃ 60 │ 61 │ 62 ┃
     ┃      ┠────┼────┼────╂────┼────┼────╂────┼────┼────┨
   2 ┫   7  ┃ 63 │ 64 │ 65 ┃ 66 │ 67 │ 68 ┃ 69 │ 70 │ 71 ┃
     ┃      ┠────┼────┼────╂────┼────┼────╂────┼────┼────┨
     ┗   8  ┃ 72 │ 73 │ 74 ┃ 75 │ 76 │ 77 ┃ 78 │ 79 │ 80 ┃
            ┗━━━━┷━━━━┷━━━━┻━━━━┷━━━━┷━━━━┻━━━━┷━━━━┷━━━━┛
```

### 位掩码表示

- 使用 27 位掩码表示每个带状区域的可能数字
- 每个位对应一个单元格
- 使用位运算进行快速更新和查询

## 主要算法流程

1. **初始化**
   - 将输入的数独转换为带状数据结构
   - 初始化所有可能的数字

2. **求解循环**
   ```rust
   loop {
       // 1. 应用锁定候选数策略
       find_locked_candidates_and_update()?;
       
       // 2. 检查是否已解决
       if is_solved() {
           return Ok(());
       }
       
       // 3. 寻找裸单元格
       if find_naked_singles()? {
           continue;
       }
       
       // 4. 如果无法继续，开始回溯
       return Ok(());
   }
   ```

3. **回溯策略**
   - 优先选择只有两个可能值的单元格
   - 保存当前状态
   - 尝试一个可能值
   - 如果失败，回退并尝试另一个可能值

## 性能优化

1. **位运算优化**
   - 使用位掩码进行快速计算
   - 通过位运算实现高效的更新和查询

2. **智能猜测**
   - 优先选择只有两个可能值的单元格
   - 减少回溯的次数

3. **带状数据结构**
   - 优化行、列和宫的处理
   - 提高缓存命中率

## 实现细节

### 主要数据结构

```rust
pub(crate) struct SudokuSolver {
    // 每个子带中可能的单元格
    poss_cells: UncheckedIndexArray<u32, 27>,
    // 用于回溯的先前状态
    prev_poss_cells: UncheckedIndexArray<u32, 27>,
    // 未解决的单元格
    unsolved_cells: UncheckedIndexArray<u32, 3>,
    // 用于优化的特殊要求
    requirement_for_weird_optimization: UncheckedIndexArray<u32, 3>,
    // 只有两个可能值的单元格
    pairs: UncheckedIndexArray<u32, 3>,
}
```

### 关键函数

1. **find_naked_singles**
   - 寻找只能填入一个数字的单元格
   - 使用位运算快速计算可能数字

2. **find_locked_candidates_and_update**
   - 寻找锁定候选数
   - 更新可能数字

3. **guess_bivalue_in_cell**
   - 在只有两个可能值的单元格中猜测
   - 保存状态并尝试

4. **guess_some_cell**
   - 在其他单元格中猜测
   - 选择最优的猜测点

## 性能特点

1. **时间复杂度**
   - 平均情况下接近线性时间
   - 最坏情况下为指数时间（但很少发生）

2. **空间复杂度**
   - 使用固定大小的数据结构
   - 内存使用效率高

3. **实际性能**
   - 在普通硬件上可以每秒解决数千个数独
   - 对于大多数数独可以在毫秒级完成

## 应用场景

1. **数独求解**
   - 快速解决任何有效的数独
   - 支持多解查找

2. **数独生成**
   - 可以用于生成特定难度的数独
   - 验证生成的数独是否有唯一解

3. **数独分析**
   - 分析数独的难度
   - 提供解题步骤 